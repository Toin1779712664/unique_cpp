= C++模板元编程

按字面意思解释，**__metaprogram__**就是**__a program about a program__**，即**__程序的程序__**，说白了就是**__用于操纵代码的程序__**。听起来好像很有逼格的样子，确实很有逼格，你用的C+++++编译器就是一段元程序，它操纵C+++++代码来生成汇编语言或机器码，这个世界上有多少人有能力写出一个编译器？

上个世纪九十年代末，某些爱钻研的小伙伴无意中发现C+++++模板可以用于编写元程序，刚开始他们只是编写元程序在编译期执行一些数值计算，后来更进一步发现除了数值计算，还可以通过模板在编译期执行类型计算，于是C+++++模板元编程作为一种**Programming Paradigm**正式登上了舞台。

促使模板元编程大行其道的最重要的原因就是效率。如果能把尽可能多的工作都放到编译期，那就意味着运行期工作量的下降，也就是说程序会跑得更快。没有什么能阻止C+++++程序员对效率的向往，虽然模板元程序如天书般难懂，但是C++++++++社区还是热情地拥抱这一新技术，大量的类库被开发出来，其中很多被纳入C+++++ 11标准中。本书就要带领你进入模板元编程的世界，一睹那些所谓的“天书”的真容。


== C++模板元编程常用技巧

元程序是在编译期由编译器直接解析并执行的，在编译期，编译器只能做整数值计算和类型计算，这就导致了元程序的代码结构和我们熟知的代码结构，也就是运行时代码结构，有很大区别。运行时代码结构通常包括常量、变量、数据结构、类、函数、循环，分支等，而元程序中只能出现常量（包括整形常量和布尔型常量）、以及循环和分支结构。

=== 常量

元程序中可以出现的常量包括**整形常量**和**布尔型常量**，为了配合编译器强大的类型计算能力，整形常量通常都被定义为某种类型，这就是C++ 11中的``integral_constant``：

==== 整形常量

[source,c++]
----
// file: type_traits

template <typename T, T v>
struct integral_constant {
    static constexpr T value =    v; // //<1>
    typedef T                     value_type;
    typedef integral_constant     type;
    
    // ...
};
----

``integral_constant``的定义虽然很简单，但是意义却很重要。它将一个数值包装成为一个对象，这从一个侧面揭示模板元编程的真谛：**编译期类型计算**。


