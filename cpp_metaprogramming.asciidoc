= C++模板元编程

按字面意思解释，**__metaprogram__**就是**__a program about a program__**，即**__程序的程序__**，说白了就是**__用于操纵代码的程序__**。听起来好像很有逼格的样子，确实很有逼格，你用的C+++++编译器就是一段元程序，它操纵C+++++代码来生成汇编语言或机器码，这个世界上有多少人有能力写出一个编译器？

上个世纪九十年代末，某些爱钻研的小伙伴无意中发现C+++++模板可以用于编写元程序，刚开始他们只是编写元程序在编译期执行一些数值计算，后来更进一步发现除了数值计算，还可以通过模板在编译期执行类型计算，于是C+++++模板元编程作为一种**Programming Paradigm**正式登上了舞台。

促使模板元编程大行其道的最重要的原因就是效率。如果能把尽可能多的工作都放到编译期，那就意味着运行期工作量的下降，也就是说程序会跑得更快。没有什么能阻止C+++++程序员对效率的向往，虽然模板元程序如天书般难懂，但是C++++++++社区还是热情地拥抱这一新技术，大量的类库被开发出来，其中很多被纳入C+++++ 11标准中。本书就要带领你进入模板元编程的世界，一睹那些所谓的“天书”的真容。


== C++模板元编程常用技巧

元程序是在编译期由编译器直接解析并执行的，在编译期，编译器只能做整数值计算和类型计算，这就导致了元程序的代码结构和我们熟知的代码结构，也就是运行时代码结构，有很大区别。运行时代码结构通常包括常量、变量、数据结构、类、函数、循环，分支等，而元程序中只能出现常量（包括整形常量和布尔型常量）、以及循环和分支结构。

=== 常量

元程序中可以出现的常量包括**整形常量**和**布尔型常量**，为了配合编译器强大的类型计算能力，整形常量通常都被定义为某种类型，这就是C++ 11中的``integral_constant``：

==== 整形常量

[source,c++]
----
// file: type_traits

template <typename T, T v>
struct integral_constant {
    static constexpr T value =    v;
    typedef T                     value_type;
    typedef integral_constant     type;
    
    // ...
};
----

上面的代码定义了一个``const integer``类型，它有一个静态类成员常量``value``，还有一个``typedef``的``type``。这是C++标准库的一个惯例：如果一个模板类有静态常量，则用``value``表示，如果有type的，则用``type``表示，例如：

[source,c++]
----
template<typename T>
struct my_meta_class {
    static constexpr int value = 0;
    typedef T            type;
};
----

这不是强制要求，但是是一个惯例，你写代码的时候，建议也遵守这个惯例。

``integral_const``的用法比较简单

[source,c++]
----
typedef integral_const<int, 2> two_type;
typedef integral_const<int, 4> four_type;

static_assert(two_type::value * 2 == four_type::value);
----

==== 布尔型常数

标准库还定义``true_type``和``false_type``，这两个类的作用和布尔型常量``true``和``false``一样

[source,c++]
----
// file: type_traits

typedef std::integral_constant<bool, true>  true_type;
typedef std::integral constant<bool, false> false_type;
----

=== 循环

在模板元编程中，一般都是用递归的方法来定义循环：

[source,c++]
----
template<size_t N>
struct factorial {
    static constexpr size_t value = N * factorial<N-1>;
};

template<>
struct factorial<1> {
    static constexpr size_t value = 1;
};

int main() {
    std::cout << factorial<5>::value << std::endl; // 20
}
----

我们知道递归必须要有结束条件，在模板元编程中，通常都用一个特化来作为结束条件，比如上面代码中的``struct factorial<1>``就是递归的结束。


=== 分支

分支结构，一般都是通过SFINA代表**S**ubstitution **F**ailure **I**s **N**ot **A**n **E**rror，来实现，最常用的就是``enable_if``：

[source,c++]
----
template<bool B, class T = void>
struct enable_if {
};

template<class T>
struct enable_if<true, T> {
    typedef T type;
};
----

如果``B``是``true``，则``enable_if``有一个``public typedef type``，否则就没有这个``typedef``。

[source,c++]
----
#include <type_traits>
#include <iostream>
#include <string>

namespace detail {struct inplace_t{};}

void* operator new(std::size_t, void* p, detail::inplace_t) {
    return p;
}

// #1, enabled via return type
template<class T, class ...Args>
typename std::enable_if<std::is_trivially_constructible<T, Args&&...>::value>::type construct(T* t, Args&&... args) {
    std::cout << "constructing trivally constructible T\n";
}

// #2,
template<class T, class... Args>
std::enable_if<!std::is_trivially_constructible<T, Args&&...>::value
construct(T* t, Args&&... args) {
    std::cout << "constructing non-trivally constructible T\n";
    new(t, detail::inplace_t{})T(args...);
}
----


元编程的主要内容就是这么多：常量类型，递归，SFINA，构成了元编程的全部。你觉得它难懂，是因为你不熟悉，一旦你熟悉了，也就没什么了。
