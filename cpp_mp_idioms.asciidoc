= 第1章 C++模板元编程

== 1. 模板元编程

如果按字面剖析单词，“metaprogram”的含义就是“a program about a program”，翻译成中文就是“程序的程序”。元程序就是用于操纵代码的程序。听起来这个概念好像有点乖乖的，其实你可能早已熟悉这方面的一些怪兽了，你手头的C++编译器就是一个例子，它操纵C++++代码来生成汇编语言或机器码。

在C\\++中，几乎是在不经意中发现模板机制为原生语言元编程提供了丰富的设施。最早的C++源程序在编译器执行整数计算，其中最早的元程序之一是Erwin Unruh在一次C++标准委员会会议上所展示的，那实际是一段不合法的代码，在其编译错误信息中含有一些列计算出来的质数值。

元程序使用模板特化来终结循环，几乎是所有C++元程序所具有的共性。

采用元程序最显而易见的理由是，通过在程序启动之前做尽可能多的工作，我们可以获得速度更快的程序。
使用元程序的一个更微妙但也更重要的理由是，这种做法可以使得计算结果和目标语言进行更深入地互动。

如果一下条件中有三个适合你，可能就应该采用元编程：

远比在编译器进行数值计算的能力重要得多的对类型进行计算。

**模板元编程**，也就是**[Template Metaprogramming](https://en.wikipedia.org/wiki/Template_metaprogramming)**，是一种编程范式（idiom），或**TPM**，是每一个有追求的C++程序员必须掌握的编程范式之一。TPM在标准库中用得十分普遍，可以说整个标准库都是基于TPM，所以要理解

Template metaprogramming (TMP) is a metaprogramming technique in which templates are used by a compiler to generate temporary source code, which is merged by the compiler with the rest of the source code and then compiled. The output of these templates include compile-time constants, data structures, and complete functions. The use of templates can be thought of as compile-time execution. The technique is used by a number of languages, the best-known being C++, but also Curl, D, and XL.

Template metaprogramming was, in a sense, discovered accidentally.[1][2]

## 2. 编译期常数

我们知道，在使用模板元编程时，是不能使用`true`, `false`这类的布尔型常量的，因为这是运行时常量。同样，`1`, `2`也是运行时常数，也不能在编译器使用。所以我们必需想办法，把整形和布尔型常量绑定到一个`type`上面，这样编译器才有可能在编译器使用这些常量完成计算。我们来看怎么做：

### 2.1 整形常数

```
// file: type_traits

template <typename T, T v>
struct integral_constant {
    static constexpr T value =    v;
    typedef T                     value_type;
    typedef integral_constant     type;
    constexpr operator value_type() const noexcept {return value;}
    constexpr value_type operator()() const noexcept {return value;} //since C++14
};
```

上面的代码定义了一个`const integer`类型，它有一个静态类成员常量`value`，还有一个`typedef`的`type`。这是C++标准库的一个管理：如果一个模板类有静态常量，则用`value`表示，如果有type的，则用`type`表示，例如：

```
template<typename T>
struct my_meta_class {
    static constexpr int value = 0;
    typedef T            type;
};
```

这不是强制要求，但是是一个惯例，你写代码的时候，建议也遵守这个惯例。

`integral_const`的用法比较简单

```
typedef integral_const<int, 2> two_type;
typedef integral_const<int, 4> four_type;

static_assert(two_type::value * 2 == four_type::value);
```

### 2.2 布尔型常数

标准库还定义`true_type`和`false_type`，这两个类的作用和布尔型常量`true`和`false`一样

```
// file: type_traits

typedef std::integral_constant<bool, true>  true_type;
typedef std::integral constant<bool, false> false_type;
```

## 3. 递归

在模板元编程中，常用递归的手法定义，一个经典的例子是计算阶乘，比如

```
5! = 5 * 4 * 3 * 2 * 1
```

用模板元来表示

```
template<size_t N>
struct factorial {
    static constexpr size_t value = N * factorial<N-1>;
};

template<>
struct factorial<1> {
    static constexpr size_t value = 1;
};

int main() {
    std::cout << factorial<5>::value << std::endl; // 20
}

```

我们知道递归必须要有结束条件，在模板元编程中，通常都用一个特化来作为结束条件，比如上面代码中的`struct factorial<1>`就是递归的结束。

## 3. SFINAE

SFINA代表**S**ubstitution **F**ailure **I**s **N**ot **A**n **E**rror，